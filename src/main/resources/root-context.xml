<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc"
	xmlns:jdbc="http://www.springframework.org/schema/jdbc" xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-4.0.xsd
		http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd
		http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd">
	<!-- 包扫描 -->
	<context:component-scan base-package="com.lu"></context:component-scan>
	<!-- 支持注解 -->
	<mvc:annotation-driven />
	<!-- viewResolver -->
	<bean id="viewResolver"
		class="org.springframework.web.servlet.view.InternalResourceViewResolver">
		<property name="viewClass"
			value="org.springframework.web.servlet.view.JstlView" />
		<property name="prefix" value="/WEB-INF/views/" />
		<property name="suffix" value=".jsp" />
	</bean>
	<context:property-placeholder location="classpath:db.properties" />
	<!-- dataSource配置 -->
	<bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"
		destroy-method="close">
		<property name="driverClass" value="${jdbc.driver}" />
		<property name="jdbcUrl" value="${jdbc.jdbcUrl}" />
		<property name="user" value="${jdbc.user}" />
		<property name="password" value="${jdbc.password}" />
	</bean>

	<!-- 事务管理 -->
	<bean id="transactionManager"
		class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
		<property name="dataSource" ref="dataSource" />
	</bean>

	<!-- 扫描mapper包 -->
	<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
		<property name="basePackage" value="com.lu.persistence" />
	</bean>
	<!-- mybatis注入sqlSessionFactory -->
	<bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
		<property name="dataSource" ref="dataSource" />
		<!--configLocation属性指定mybatis的核心配置文件 -->
		<property name="configLocation" value="classpath:Configuration.xml" />
		<!-- 所有配置的mapper文件 -->
		<!-- <property name="mapperLocations" value="classpath*:com/lu/mapping/*.xml" 
			/> -->
	</bean>
	<mvc:resources location="/WEB-INF/resources/" mapping="/resources/**" />
	<mvc:resources location="/WEB-INF/resources/image/favicon.ico" mapping="/favicon.ico" />
	  


	<!-- shiro 相关的配置 -->
	<!-- <bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean">
		<property name="securityManager" ref="securityManager" />
		override these for application-specific URLs if you like: <property 
			name="loginUrl" value="/login.jsp"/> <property name="successUrl" value="/home.jsp"/> 
			<property name="unauthorizedUrl" value="/unauthorized.jsp"/>
		The 'filters' property is not necessary since any declared javax.servlet.Filter 
			bean
		defined will be automatically acquired and available via its beanName 
			in chain
		definitions, but you can perform instance overrides or name aliases 
			here if you like:
		<property name="filters"> <util:map> <entry key="anAlias" value-ref="someFilter"/> 
			</util:map> </property>
		<property name="filterChainDefinitions">
			<value>
				# some example chain definitions:
				/admin/** = authc, roles[admin]
				/docs/** = authc, perms[document:read]
				/** = authc
				# more URL-to-FilterChain definitions here
			</value>
		</property>
	</bean>

	Define any javax.servlet.Filter beans you want anywhere in this application 
		context.
	They will automatically be acquired by the 'shiroFilter' bean above 
		and made available
	to the 'filterChainDefinitions' property. Or you can manually/explicitly 
		add them
	to the shiroFilter's 'filters' Map if desired. See its JavaDoc for 
		more details.
	<bean id="someFilter" class="..." />
	<bean id="anotherFilter" class="...">
	</bean>

	<bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager">
		Single realm app. If you have multiple realms, use the 'realms' property 
			instead.
		<property name="realm" ref="myRealm" />
		By default the servlet container sessions will be used. Uncomment 
			this line to use shiro's native sessions (see the JavaDoc for more):
		<property name="sessionMode" value="native"/>
	</bean>
	<bean id="lifecycleBeanPostProcessor" class="org.apache.shiro.spring.LifecycleBeanPostProcessor" />
	Define the realm you want to use to connect to your back-end security 
		datasource:
	<bean id="myRealm" class="...">
	</bean>

	<bean id="securityManager" class="org.apache.shiro.mgt.DefaultSecurityManager">
		Single realm app. If you have multiple realms, use the 'realms' property 
			instead.
		<property name="realm" ref="myRealm" />
	</bean>
	<bean id="lifecycleBeanPostProcessor" class="org.apache.shiro.spring.LifecycleBeanPostProcessor" />

	For simplest integration, so that all SecurityUtils.* methods work 
		in all cases,
	make the securityManager bean a static singleton. DO NOT do this in 
		web
	applications - see the 'Web Applications' section below instead.
	<bean
		class="org.springframework.beans.factory.config.MethodInvokingFactoryBean">
		<property name="staticMethod"
			value="org.apache.shiro.SecurityUtils.setSecurityManager" />
		<property name="arguments" ref="securityManager" />
	</bean> -->
</beans>